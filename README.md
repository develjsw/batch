### NestJS Batch Server

- **Redis 기반 분산 락 적용**
  - Batch 서버가 다중 인스턴스로 실행되거나, Docker 기반으로 컨테이너가 수평 확장되는 환경에서 **Cron Job의 중복 실행을 방지**하기 위해 Redis 분산 락을 적용
  - Cron 주기의 약 70% 수준으로 **락 만료 시간(TTL)** 을 설정하여, 작업 도중 중단되더라도 다음 주기 실행에 영향을 주지 않도록 설계
    - TTL이 너무 짧으면 작업이 완료되기 전에 락이 만료되어 **중복 실행 위험**이 존재
    - 반대로 TTL이 너무 길면, 작업 실패 후 락이 해제되지 않았을 경우 **다음 주기 실행이 지연될 수 있음**
    - 다만, 현재 구조에서는 작업 실패 시에도 `finally` 블록을 통해 락을 명시적으로 해제하기 때문에, 일반적인 경우 TTL이 남아 있어도 락은 **즉시 해제됨**
    - 그럼에도 불구하고 서버 다운, 네트워크 장애 등으로 `finally`가 실행되지 못하는 예외 상황에 대비해, TTL은 **백업 안전장치로 반드시 필요**
    - 따라서 TTL을 Cron 주기의 약 70%로 설정하면, **작업 완료 보장과 장애 복구 속도 사이의 균형을 확보**할 수 있음
  - `ioredis`와 `redlock` 라이브러리 사용
    - `redlock`은 약 3년 전 5.0.0-beta.2 버전 이후로 업데이트는 없지만, **가장 널리 사용되는 Redis 기반 분산 락 구현체**이며 안정성이 입증되어 있어 대체 없이 사용


- **Graceful Shutdown 적용**
  - 배치 작업 도중 애플리케이션이 종료되더라도, 현재 실행 중인 작업을 안전하게 마무리할 수 있도록 Graceful Shutdown 로직 구현
  - NestJS의 enableShutdownHooks() 기능을 활성화하고, ShutdownHandler를 전역 서비스로 등록하여 종료 시그널(SIGINT, SIGTERM 등) 을 감지
  - 각 배치 서비스는 BaseBatchService를 상속하여 종료 콜백을 등록하고, 현재 실행 중인 작업(Promise)이 완료될 때까지 종료를 지연시킴
  - 이를 통해 다음과 같은 시나리오에서도 데이터 정합성과 안정적인 종료를 보장
    - 서버 배포로 인한 재시작
    - 컨테이너의 수평 축소 및 제거
    - 수동으로 서버 중지
  - NestJS에서 기본 제공하는 onApplicationShutdown이나 onModuleDestroy만으로는 @Cron() 기반 작업의 정상 종료를 보장할 수 없음 
    - @Cron()은 내부적으로 비동기 작업을 트리거하지만, NestJS는 해당 작업이 완료될 때까지 자동으로 대기하지 않음
    - 따라서 별도의 작업 추적 로직과 Promise 기반 상태 관리가 필요
    - 이를 위해 BaseBatchService를 설계하여 작업 실행 및 종료 대기 처리를 통합적으로 관리
  - 결과적으로, 비동기 작업이 완료되기 전에는 애플리케이션이 완전히 종료되지 않으며, 종료 로직 내 로그를 통해 진행 상태를 명확히 확인할 수 있음